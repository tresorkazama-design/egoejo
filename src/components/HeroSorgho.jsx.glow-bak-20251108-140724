import { useEffect, useRef, useState, Suspense } from "react";

/* ---------- Fallback (no WebGL) ---------- */
function FallbackHero() {
  return (
    <div className="section section--dark"
         style={{minHeight:"65svh", display:"grid", placeItems:"center"}} />
  );
}

/* ---------- Sorghum grain texture ---------- */
function makeSorghumTexture(THREE) {
  const size = 64;
  const c = document.createElement("canvas");
  c.width = c.height = size;
  const ctx = c.getContext("2d");

  ctx.clearRect(0,0,size,size);
  const cx = size/2, cy = size/2;
  const rx = size*0.34, ry = size*0.22;

  const grad = ctx.createRadialGradient(cx-8, cy-6, rx*0.1, cx, cy, rx);
  grad.addColorStop(0,   "#c7934e"); // centre un peu plus sombre
  grad.addColorStop(0.5, "#9a6a34"); // milieu
  grad.addColorStop(1,   "#5a330f"); // bord
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.ellipse(cx, cy, rx, ry, Math.PI/12, 0, Math.PI*2);
  ctx.fill();

  const tex = new THREE.CanvasTexture(c);
  tex.needsUpdate = true;
  tex.flipY = false;
  return tex;
}

/* ---------- WebGL cloud ---------- */
const MAX_PARTICLES   = 160000;   // cap dur (adapté plus bas si besoin)
const PARTICLE_SIZE   = 0.02;     // taille du sprite
const BOUNDS          = { x: 12, y: 3.2, z: 6.5 };
const WIND            = 0.008;    // vent léger
const SWIRL           = 0.003;    // turbulence légère
const FALL            = 0.00025;  // gravité douce

function SorghoWebGL() {
  const mountRef = useRef(null);

  useEffect(() => {
    let renderer, scene, camera, points, animId, ro;
    let velocities, geo;
    (async () => {
      const THREE = await import("three");
      const el = mountRef.current;
      const w = el.clientWidth, h = el.clientHeight;

      renderer = new THREE.WebGLRenderer({ antialias:false, alpha:true });
      renderer.setSize(w, h);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      el.appendChild(renderer.domElement);

      scene = new THREE.Scene(); scene.background = null;
      camera = new THREE.PerspectiveCamera(60, w/h, 0.1, 100);
      camera.position.set(0, 0.65, 10);

      // Densité auto selon mémoire & largeur
      const mem = navigator.deviceMemory || 4;
      const small = window.innerWidth < 768;
      const f = (mem < 4 ? 0.5 : mem < 8 ? 0.8 : 1.0) * (small ? 0.8 : 1.0);
      const COUNT = Math.max(60000, Math.floor(MAX_PARTICLES * f));

      geo = new THREE.BufferGeometry();
      const positions = new Float32Array(COUNT * 3);
      const colors    = new Float32Array(COUNT * 3);
      const tmp = new THREE.Color();
      const base = new THREE.Color("#9a6a34");

      velocities = new Float32Array(COUNT * 3);

      for (let i=0; i<COUNT; i++) {
        const ix = i*3;
        positions[ix]   = (Math.random()-0.5)*BOUNDS.x;
        positions[ix+1] = (Math.random()-0.5)*BOUNDS.y;
        positions[ix+2] = (Math.random()-0.5)*BOUNDS.z;

        tmp.copy(base).offsetHSL((Math.random()-0.5)*0.02, (Math.random()-0.5)*0.04, (Math.random()-0.5)*0.03);
        colors[ix] = tmp.r; colors[ix+1] = tmp.g; colors[ix+2] = tmp.b;

        velocities[ix]   = 0.003 + Math.random()*0.01;
        velocities[ix+1] = (Math.random()-0.5)*0.003;
        velocities[ix+2] = (Math.random()-0.5)*0.005;
      }

      geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      geo.setAttribute("color",    new THREE.BufferAttribute(colors, 3));

      const mat = new THREE.PointsMaterial({
        map: makeSorghumTexture(THREE),
        transparent: true,
        blending: THREE.NormalBlending, // pas d'halo additif
        opacity: 0.38,
        size: PARTICLE_SIZE,
        sizeAttenuation: true,
        vertexColors: true,
        depthWrite: false
      });

      points = new THREE.Points(geo, mat);
      scene.add(points);

      const onResize = () => {
        const W = el.clientWidth, H = el.clientHeight;
        renderer.setSize(W, H);
        camera.aspect = W/H; camera.updateProjectionMatrix();
      };
      ro = new ResizeObserver(onResize); ro.observe(el);

      const pos = geo.getAttribute("position");
      let t=0, paused=false;
      document.addEventListener("visibilitychange", () => paused = document.hidden);

      const animate = () => {
        t += 0.01;
        const arr = pos.array;
        for (let i=0; i<COUNT; i++) {
          const ix = i*3;
          arr[ix]   += velocities[ix]   + Math.cos(t*0.6 + arr[ix+2]) * WIND;
          arr[ix+1] += velocities[ix+1] + Math.sin(t + i*0.002) * SWIRL - FALL;
          arr[ix+2] += velocities[ix+2] + Math.sin(t*0.5 + arr[ix])   * WIND;

          if (arr[ix]   >  BOUNDS.x/2) arr[ix]   = -BOUNDS.x/2;
          if (arr[ix]   < -BOUNDS.x/2) arr[ix]   =  BOUNDS.x/2;
          if (arr[ix+1] >  BOUNDS.y/2) arr[ix+1] = -BOUNDS.y/2;
          if (arr[ix+1] < -BOUNDS.y/2) arr[ix+1] =  BOUNDS.y/2;
          if (arr[ix+2] >  BOUNDS.z/2) arr[ix+2] = -BOUNDS.z/2;
          if (arr[ix+2] < -BOUNDS.z/2) arr[ix+2] =  BOUNDS.z/2;
        }
        pos.needsUpdate = true;

        if (!paused) renderer.render(scene, camera);
        animId = requestAnimationFrame(animate);
      };
      animate();

      return () => {
        cancelAnimationFrame(animId);
        ro && ro.disconnect();
        renderer && renderer.dispose();
        el && (el.innerHTML = "");
      };
    })();

    return () => void 0;
  }, []);

  return (
    <div className="section section--dark"
         style={{position:"relative", minHeight:"65svh", overflow:"hidden"}}>
      <div ref={mountRef} style={{position:"absolute", inset:0, zIndex:1, pointerEvents:"none"}}/>
    </div>
  );
}

/* ---------- Wrapper with force switches ---------- */
export default function HeroSorgho(){
  const [ok, setOk] = useState(false);
  useEffect(() => {
    const qs = new URLSearchParams(location.search);
    const force    = qs.get("hero") === "force";
    const fallback = qs.get("hero") === "fallback";

    if (fallback) { setOk(false); return; }
    if (force)    { setOk(true);  return; }

    const reduce = matchMedia("(prefers-reduced-motion: reduce)").matches;
    const webgl = (() => {
      try {
        const canvas = document.createElement("canvas");
        return !!(window.WebGLRenderingContext &&
          (canvas.getContext("webgl") || canvas.getContext("experimental-webgl")));
      } catch { return false; }
    })();

    setOk(!reduce && webgl);
  }, []);

  return ok ? <Suspense fallback={<FallbackHero/>}><SorghoWebGL/></Suspense>
            : <FallbackHero/>;
}